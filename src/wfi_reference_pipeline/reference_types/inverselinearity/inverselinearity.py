import logging

import numpy as np
import roman_datamodels.stnode as rds
from astropy import units as u
from astropy.io import fits

from wfi_reference_pipeline.resources.wfi_meta_inverselinearity import (
    WFIMetaInverseLinearity,
)

from ..reference_type import ReferenceType


class InverseLinearity(ReferenceType):
    """
    Class InverseLinearity() inherits the ReferenceType() base class methods
    where static meta data for all reference file types are written. The
    method get_coeffs_from_dcl retrieves inverse linearity coefficients
    determined from DCL data by Bellini et al. (~2021), which are used to
    make these reference files with intended use by romanisim only. There
    is not currently any plan to produce these reference files for use
    in romancal standard processing.
    """

    def __init__(
            self,
            meta_data,
            file_list=None,
            ref_type_data=None,
            bit_mask=None,
            outfile="roman_inverselinearity.asdf",
            clobber=False,
    ):

        """
        The __init__ method initializes the class with proper input variables needed by the ReferenceType()
        file base class.

        Parameters
        ----------
        meta_data: Object; default = None
            Object of meta information converted to dictionary when writing reference file.
        file_list: List of strings; default = None
            List of file names with absolute paths. Intended for primary use during automated operations.
        ref_type_data: numpy array; default = None
            Input which can be image array or data cube. Intended for development support file creation or as input
            for reference file types not generated from a file list.
        bit_mask: 2D integer numpy array, default = None
            A 2D data quality integer mask array to be applied to reference file.
        outfile: string; default = roman_flat.asdf
            File path and name for saved reference file.
        clobber: Boolean; default = False
            True to overwrite outfile if outfile already exists. False will not overwrite and exception
            will be raised if duplicate file found.
        ---------

        See reference_type.py base class for additional attributes and methods.
        """

        # Access methods of base class ReferenceType
        super().__init__(
            meta_data=meta_data,
            file_list=file_list,
            ref_type_data=ref_type_data,
            bit_mask=bit_mask,
            outfile=outfile,
            clobber=clobber
        )

        # Default meta creation for module specific ref type.
        if not isinstance(meta_data, WFIMetaInverseLinearity):
            raise TypeError(
                f"Meta Data has reftype {type(meta_data)}, expecting WFIMetaInverseLinearity"
            )
        if len(self.meta_data.description) == 0:
            self.meta_data.description = "Roman WFI inverse linearity reference file."

        logging.debug(f"Default flat reference file object: {outfile} ")

        # Attributes to make reference file with valid data model.
        self.inverselinearity_coefficients = None  # The attribute 'data' in data model.

        # Module flow creating reference file
        if self.file_list:
            raise TypeError(
                "The algorithm generate inverse linearity coefficients i snot implemented yet."
            )
        else:
            if not isinstance(ref_type_data, (np.ndarray, u.Quantity)):
                raise TypeError(
                    "Input data is neither a numpy array nor a Quantity object."
                )
            if isinstance(ref_type_data, u.Quantity):  # Only access data from quantity object.
                ref_type_data = ref_type_data.value
                logging.debug("Quantity object detected. Extracted data values.")

            dim = ref_type_data.shape
            if len(dim) == 3:
                logging.debug("The input 3D data array is now self.inverselinearity_coefficients.")
                self.inverselinearity_coefficients = ref_type_data
                logging.debug("Ready to generate reference file.")
            else:
                raise ValueError(
                    "Input data is not a valid numpy array of dimension 3."
                )

    def get_coeffs_from_dcl(self, wfi_det='WFI01'):
        """
        The method get_coeffs_from_dcl() will take as input a WFI detector id  and retrieve the inverse linearity
        coefficients from group roman on central storage from files generated by A. Bellini ~2021.

        NOTE: There is additional conditioning of the DCL data that is required to generate
        proper test data. See note below in update_dq_mask() method.

        Parameters
        ----------
        wfi_det: string; default = "WFI01"
            Variable to identify which detector maps to what sca file id.
        """

        wfi_arr = ["WFI01", "WFI02", "WFI03", "WFI04", "WFI05", "WFI06", "WFI07", "WFI08", "WFI09", "WFI10", "WFI11",
                   "WFI12", "WFI13", "WFI14", "WFI15", "WFI16", "WFI17", "WFI18"]

        sca_id_arr = [22066, 21815, 21946, 22073, 21816, 20663, 22069, 21641, 21813, 22078, 21947, 22077, 22067, 21814,
                      21645, 21643, 21319, 20833]

        # Create a dictionary to map all wfi detectors to sca id numbers.
        wfi_to_sca = dict(zip(wfi_arr, sca_id_arr))
        sca_id = wfi_to_sca[wfi_det] # noqa F841

        # Make inverse linearity file string with absolute path to central storage from the detector input and the
        # mapping to WFI tags.
        det_number = int(wfi_det[3:])
        inv_file_dir = '/grp/roman/bellini/WFIsim/CNL/new/'
        inv_file = inv_file_dir + 'LNC_SCA' + str(det_number).zfill(2) + '.fits'

        # Open the SCA file to get inverse linearity coefficients as np.float32.
        with fits.open(inv_file) as hdul:
            self.inverselinearity_coefficients = hdul[0].data.astype(np.float32)

        # Update meta data based on input to getting DCL inverse linearity coefficients and add sci id
        self.meta_data.instrument_detector = wfi_det
        self.meta_data.pedigree = 'GROUND'
        # TODO evaluate adding new meta to ref type meta not required
        self.meta_data['instrument_sca_id'] = {'SCA': sca_id}

    def calculate_error(self):
        """
        Abstract method not applicable to Gain.
        """

        pass

    def update_data_quality_array(self, tolerance=1):
        """
        Update data quality array bit mask with flag integer value.

        NOTE: For DMS 24Q1 B12 the test data created by WFIsim needed new reference files to
        match those on CRDS and it was found that DCL data had zeros for all coefficients
        in detectors which needed to be replaced. The linearity and inverse linearity coefficients
        flagging should match, but filtering and replacing them seems more straightforward.

        Parameters
        ----------
        tolerance: float; default = 1.0,
           The number of counts away from the test count value to determine if a pixel has
           adequate inverse linearity coefficients.
        """

        # Look at DCL data for zero in linear term and replace with array to return count value.
        # Applying no correction for DCL data that didn't generate inverse coefficients.
        bad_dcl_data = np.where(self.inverselinearity_coefficients[1, :, :] == 0)
        replacement_coefficients = np.array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float32)
        for x, y in zip(bad_dcl_data[0], bad_dcl_data[1]):
            self.inverselinearity_coefficients[:, x, y] = replacement_coefficients

        # Check the inverse linearity coefficients with a test count rate.
        test_count = 20000.
        #TODO confirm tolerance with calibration block for default value.
        test_count_value_array = np.polyval(self.inverselinearity_coefficients[::-1], test_count)

        # Compare test count rate and see if outside the tolerance.
        differences = np.abs(test_count_value_array - test_count)
        outside_tolerance = differences > (tolerance * test_count)

        # Update mask based on where the test was outside the tolerance.
        self.mask[outside_tolerance] += self.dqflag_defs['NONLINEAR']

    def populate_datamodel_tree(self):
        """
        Create data model from DMS and populate tree.
        """

        # Construct the dark object from the data model.
        inverselinearity_datamodel_tree = rds.InverselinearityRef()
        inverselinearity_datamodel_tree['meta'] = self.meta_data.export_asdf_meta()
        inverselinearity_datamodel_tree['coeffs'] = self.inverselinearity_coefficients
        inverselinearity_datamodel_tree['dq'] = self.mask

        return inverselinearity_datamodel_tree
