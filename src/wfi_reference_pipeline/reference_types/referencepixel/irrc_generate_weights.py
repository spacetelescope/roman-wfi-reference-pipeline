'''
Computes the alpha (reference output), gamma (left reference pixels) and zeta (right reference pixels) frequency-dependent
gain weight streams from sums that were generated by repeated runs of irrc_extract_ramp_sums.

Written by (Rauscher et al., in prep):
    - R. Arendt
    - S. Maher
'''

import glob
import h5py
import numpy as np
import time

from .irrc_constants import NUM_ROWS, NUM_COLS_PER_OUTPUT_CHAN_WITH_PAD, NUM_OUTPUT_CHANS
from .irrc_util import exec_channel_func_threads

# Allocate singleton logger
import logging
logger = logging.getLogger('ReferencePixel Weights')

# Type used for storing weights (alpha, gamma, zeta)
cfg_weights_dtype = np.complex128
    


def generate(in_file_search_tag:str="*.hd5",
             lambda_coeff:float=0, multithread:bool=True):
    '''
    Generated output file with weights from one or more input previously processed ramp sums
    :param in_file_search_tag: Python glob pattern for files generated using 'extract_ramp_sums.py'
    :param lambda_coeff: a scaling factor
    :param multithread: should the computations use multithreading?
    '''
    
    start_sec = time.time()
    
    in_files = glob.glob(in_file_search_tag)
    if len(in_files) < 1:
        raise FileNotFoundError("in_file_search_tag found 0 in_files: ", in_file_search_tag)
    
    logger.info('Reading in ramp sums')

    first_file = True
    for infile in in_files:
        logger.info(f'    Reading input file: {infile}')    
        with h5py.File(infile, 'r') as hf:
            if first_file:
                freq = hf["freq"][:]  # [:] to get as numpy array
                sum_na = hf["sum_na"][:] # (n x n*)
                sum_nl = hf["sum_nl"][:] # (n x l*)
                sum_nr = hf["sum_nr"][:] # (n x r*)
                sum_ll = hf["sum_ll"][:] # (l x l*)
                sum_rr = hf["sum_rr"][:] # (r x r*)
                sum_lr = hf["sum_lr"][:] # (l x r*)
                                
                first_file = False
            else:
                sum_na += hf["sum_na"][:] # (n x n*)
                sum_nl += hf["sum_nl"][:] # (n x l*)
                sum_nr += hf["sum_nr"][:] # (n x r*)
                sum_ll += hf["sum_ll"][:] # (l x l*)
                sum_rr += hf["sum_rr"][:] # (r x r*)
                sum_lr += hf["sum_lr"][:] # (l x r*)
    
    logger.info('Construct the reference pixel power filter')
    
    # ; construct the reference pixel power filter [1,cos,0,cos,1]
    elen = 512  # length of apodization cosine filter
    blen = NUM_ROWS - elen  # max unfiltered frequency (= row freq = 1450 Hz)
    cos_filter = (np.cos(np.arange(elen, dtype=np.float64) * np.pi / elen) + 1) / 2.0
    a = np.hstack((np.ones(blen, dtype=np.float64), cos_filter, np.zeros(int(NUM_COLS_PER_OUTPUT_CHAN_WITH_PAD * NUM_ROWS / 2 - 2 * blen - 2 * elen), dtype=np.float64), np.flip(cos_filter), np.ones(blen, dtype=np.float64)))
    a2 = np.hstack((a, np.flip(np.roll(a, -1))))
    filter_r = a2

    # ignore negative frequencies now that we're doing real-only FFTs
    filter_r = filter_r[:filter_r.size // 2 + 1]
        
    # reference amplifier (a x a*)    
    aa = sum_na[-1,:].real + lambda_coeff * freq.size 
    # left amplifier (l x l*)
    ll = sum_ll + lambda_coeff * freq.size
    # right amplifier (r x r*)
    rr = sum_rr + lambda_coeff * freq.size

    # (a x l*)*
    uu = np.conjugate(sum_nl[-1,:])
    # (a x r*)*
    vv = np.conjugate(sum_nr[-1,:])

    regular_col_slice = slice(0, NUM_OUTPUT_CHANS - 1)
    # (n x n*)
    ww = sum_na[regular_col_slice,:]
    # (n x r*)
    xx = sum_nr[regular_col_slice,:]
    # (n x l*)
    yy = sum_nl[regular_col_slice,:]
    # (l x r*)*
    zz = np.conjugate(sum_lr)
                           
    #  *** !!! Caution. Not clear if this application of the filter is correct.
    #  It is generalized from the 2-stream corrections of IRS^2, but I'm not sure
    #  of the derivation of the usage there. R. Arendt
    uu *= filter_r
    vv *= filter_r

    xx[regular_col_slice,:] *= np.conjugate(filter_r)
    yy[regular_col_slice,:] *= np.conjugate(filter_r)

    #TODO : access if conj_uu and uu, etc, can be simplified.  
    conj_uu = np.conjugate(uu) # sum_nl[-1,:]
    conj_vv = np.conjugate(vv) # sum_nr[-1,:]
    conj_zz = np.conjugate(zz) # sum_lr
    
    denom = aa * ll * rr - rr * uu * conj_uu - ll * vv * conj_vv + uu * zz * conj_vv - aa * zz * conj_zz + vv * conj_uu * conj_zz
    
    # Do weight calculations in complex128 but optional
    # precision downgrade for storage/speed available below
    alpha = np.empty(ww.shape, dtype=np.complex128)
    gamma = np.empty(ww.shape, dtype=np.complex128)
    zeta = np.empty(ww.shape, dtype=np.complex128)   
                    
    logger.info('Weight calculation ..')    
    exec_channel_func_threads(range(NUM_OUTPUT_CHANS - 1), _channel_coeff_func, (alpha, gamma, zeta, aa, ll, rr, uu, vv, ww, xx, yy, zz, conj_uu, conj_vv, conj_zz, denom), multithread=multithread)
    
    alpha = alpha.astype(cfg_weights_dtype)
    gamma = gamma.astype(cfg_weights_dtype)
    zeta = zeta.astype(cfg_weights_dtype)
        
    logger.info(f'Total wall-clock execution (seconds):  {time.time() - start_sec}')
    logger.info('Done')
    
    return alpha, gamma, zeta

    
def _channel_coeff_func(chan:int, alpha:np.ndarray, gamma:np.ndarray, zeta:np.ndarray,
                        aa:np.ndarray, ll:np.ndarray, rr:np.ndarray, uu:np.ndarray, vv:np.ndarray, ww:np.ndarray, xx:np.ndarray, yy:np.ndarray, zz:np.ndarray,
                        conj_uu:np.ndarray, conj_vv:np.ndarray, conj_zz:np.ndarray, denom:np.ndarray):
    '''
    Generate the three streams for a single channel
    :param chan: channel number
    :param alpha: CHANGED IN PLACE - weights for reference output 
    :param gamma: CHANGED IN PLACE - weights for left reference columns
    :param zeta: CHANGED IN PLACE - weights for right reference columns
    
    The following are intermediate quantities calculated a priori
    :param aa:
    :param ll:
    :param rr:
    :param uu:
    :param vv:
    :param ww:
    :param xx:
    :param yy:
    :param zz:
    :param conj_uu:
    :param conj_vv:
    :param conj_zz:
    :param denom:
    '''
    
    alpha[chan,:] = (ll * rr * ww[chan,:] - ll * vv * xx[chan,:] - rr * uu * yy[chan,:] + uu * xx[chan,:] * zz + vv * yy[chan,:] * conj_zz - ww[chan,:] * zz * conj_zz) / denom
    gamma[chan,:] = (aa * rr * yy[chan,:] - aa * xx[chan,:] * zz - rr * ww[chan,:] * conj_uu + vv * xx[chan,:] * conj_uu - vv * yy[chan,:] * conj_vv + ww[chan,:] * zz * conj_vv) / denom
    zeta[chan,:] = (aa * ll * xx[chan,:] - uu * xx[chan,:] * conj_uu - ll * ww[chan,:] * conj_vv + uu * yy[chan,:] * conj_vv - aa * yy[chan,:] * conj_zz + ww[chan,:] * conj_uu * conj_zz) / denom


