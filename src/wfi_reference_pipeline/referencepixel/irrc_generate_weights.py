'''
Computes the alpha (reference output), gamma (left reference pixels) and zeta (right reference pixels) frequency-dependent
gain weight streams from sums that were generated by repeated runs of extract_ramp_sums.  This "training" is 
typically done "rarely" - e.g., to capture the common noise of a particular detector configuration or experiment - and subsequently applied
repeatedly to new science data to apply the IRRC reduction.

@author: rarendt
@author: smaher
'''

import glob
import h5py
from irrc_constants import NUM_ROWS, NUM_COLS_PER_OUTPUT_CHAN_WITH_PAD, NUM_OUTPUT_CHANS
import numpy as np
import time
# from irrc import logger, config
from irrc_util import exec_channel_func_threads

# Allocate singleton logger
# logger = logger.get_logger(__name__)

# The default name for the weights file name
cfgDefaultIrrcCoeffsFilename = "irrc_coeffs.h5"
# Type used for storing weights (alpha, gamma, zeta)
cfgWeightsDtype = np.complex128
    
def generate(inFileSearchTag:str="*.hd5", outFileName:str=cfgDefaultIrrcCoeffsFilename,
             lambdaCoeff:float=0, multiThread:bool=True):
    '''
    Generated output file with weights from one or more input previously processed ramp sums
    :param inFileSearchTag: Python glob pattern for files generated using 'extract_ramp_sums.py'
    :param outFileName: output weights file name
    :param lambdaCoeff: a scaling factor
    :param multiThread: should the computations use multithreading?
    '''
    
    startSec = time.time()
    
    inFiles = glob.glob(inFileSearchTag)
    if len(inFiles) < 1:
        raise FileNotFoundError("inFileSearchTag found 0 inFiles: ", inFileSearchTag)

    # logger.info(f'Output file = {outFileName}')
    
    # logger.info('Reading in ramp sums')

    firstFile = True
    for inFile in inFiles:
        # logger.info(f'    Reading input file: {inFile}')    
        with h5py.File(inFile, 'r') as hf:
            if firstFile:
                freq = hf["freq"][:]  # [:] to get as numpy array
                sum_na = hf["sum_na"][:]
                sum_nl = hf["sum_nl"][:]
                sum_nr = hf["sum_nr"][:]
                sum_ll = hf["sum_ll"][:]
                sum_rr = hf["sum_rr"][:]
                sum_lr = hf["sum_lr"][:]
                                
                firstFile = False
            else:
                sum_na += hf["sum_na"][:]
                sum_nl += hf["sum_nl"][:]
                sum_nr += hf["sum_nr"][:]
                sum_ll += hf["sum_ll"][:]
                sum_rr += hf["sum_rr"][:]
                sum_lr += hf["sum_lr"][:]
    
    # logger.info(f'Construct the reference pixel power filter')
    
    # ; construct the reference pixel power filter [1,cos,0,cos,1]
    elen = 512  # length of apodization cosine filter
    blen = NUM_ROWS - elen  # max unfiltered frequency (= row freq = 1450 Hz)
    cosFilter = (np.cos(np.arange(elen, dtype=np.float64) * np.pi / elen) + 1) / 2.0
    a = np.hstack((np.ones(blen, dtype=np.float64), cosFilter, np.zeros(int(NUM_COLS_PER_OUTPUT_CHAN_WITH_PAD * NUM_ROWS / 2 - 2 * blen - 2 * elen), dtype=np.float64), np.flip(cosFilter), np.ones(blen, dtype=np.float64)))
    a2 = np.hstack((a, np.flip(np.roll(a, -1))))
    filter_r = a2

    # ignore negative frequencies now that we're doing real-only FFTs
    filter_r = filter_r[:filter_r.size // 2 + 1]
        
    A = sum_na[-1,:].real + lambdaCoeff * freq.size
    L = sum_ll + lambdaCoeff * freq.size
    R = sum_rr + lambdaCoeff * freq.size

    U = np.conjugate(sum_nl[-1,:])
    V = np.conjugate(sum_nr[-1,:])

    regularColSlice = slice(0, NUM_OUTPUT_CHANS - 1)
    W = sum_na[regularColSlice,:]
    X = sum_nr[regularColSlice,:]
    Y = sum_nl[regularColSlice,:]
    Z = np.conjugate(sum_lr)
                           
    # ; *** !!! Caution. Not clear if this application of the filter is correct.
    # ; It is generalized from the 2-stream corrections of IRS^2, but I'm not sure
    # ; of the derivation of the usage there. R. Arendt
    U *= filter_r
    V *= filter_r
    
    for c in range(NUM_OUTPUT_CHANS - 1):
        X[c,:] *= np.conjugate(filter_r)
        Y[c,:] *= np.conjugate(filter_r)
    
    conjU = np.conjugate(U)
    conjV = np.conjugate(V)
    conjZ = np.conjugate(Z)
    
    denom = A * L * R - R * U * conjU - L * V * conjV + U * Z * conjV - A * Z * conjZ + V * conjU * conjZ
    
    #
    # Do weight calculations in complex128 but optional
    # precision downgrade for storage/speed available below
    #
    alpha = np.empty(W.shape, dtype=np.complex128)
    gamma = np.empty(W.shape, dtype=np.complex128)
    zeta = np.empty(W.shape, dtype=np.complex128)   
                    
    # logger.info('Weight calculation ..')    
    exec_channel_func_threads(range(NUM_OUTPUT_CHANS - 1), _channel_coeff_func, (alpha, gamma, zeta, A, L, R, U, V, W, X, Y, Z, conjU, conjV, conjZ, denom), multiThread=multiThread)
    
    alpha = alpha.astype(cfgWeightsDtype)
    gamma = gamma.astype(cfgWeightsDtype)
    zeta = zeta.astype(cfgWeightsDtype)
    
    # logger.info(f'Writing weights to file {outFileName}') 
    with h5py.File(outFileName, 'w') as hf:
        hf.create_dataset("files", data=inFiles)
        hf.create_dataset("freq", data=freq)
        hf.create_dataset("alpha", data=alpha)
        hf.create_dataset("gamma", data=gamma)
        hf.create_dataset("zeta", data=zeta)
        hf.create_dataset("lambda", data=lambdaCoeff)
        
    # logger.info(f'Total wall-clock execution (seconds):  {time.time() - startSec}')
    # logger.info('Done')
    
    return freq, alpha, gamma, zeta, lambdaCoeff

    
def _channel_coeff_func(chan:int, alpha:np.ndarray, gamma:np.ndarray, zeta:np.ndarray,
                        A:np.ndarray, L:np.ndarray, R:np.ndarray, U:np.ndarray, V:np.ndarray, W:np.ndarray, X:np.ndarray, Y:np.ndarray, Z:np.ndarray,
                        conjU:np.ndarray, conjV:np.ndarray, conjZ:np.ndarray, denom:np.ndarray):
    '''
    Generate the three streams for a single channel
    :param chan: channel number
    :param alpha: CHANGED IN PLACE - weights for reference output 
    :param gamma: CHANGED IN PLACE - weights for left reference columns
    :param zeta: CHANGED IN PLACE - weights for right reference columns
    
    The following are intermediate quantities calculated a priori
    :param A:
    :param L:
    :param R:
    :param U:
    :param V:
    :param W:
    :param X:
    :param Y:
    :param Z:
    :param conjU:
    :param conjV:
    :param conjZ:
    :param denom:
    '''
    
    alpha[chan,:] = (L * R * W[chan,:] - L * V * X[chan,:] - R * U * Y[chan,:] + U * X[chan,:] * Z + V * Y[chan,:] * conjZ - W[chan,:] * Z * conjZ) / denom
    gamma[chan,:] = (A * R * Y[chan,:] - A * X[chan,:] * Z - R * W[chan,:] * conjU + V * X[chan,:] * conjU - V * Y[chan,:] * conjV + W[chan,:] * Z * conjV) / denom
    zeta[chan,:] = (A * L * X[chan,:] - U * X[chan,:] * conjU - L * W[chan,:] * conjV + U * Y[chan,:] * conjV - A * Y[chan,:] * conjZ + W[chan,:] * conjU * conjZ) / denom


